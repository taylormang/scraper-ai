export interface FieldDefinition {
  type: 'string' | 'number' | 'boolean' | 'array' | 'object';
  required: boolean;
  arrayItemType?: 'string' | 'number' | 'object';
  defaultValue?: any;
  exampleValue?: any;
}

export interface AutoGeneratedSchema {
  name: string;
  generatedFrom: string;
  sampleSize: number;
  fields: Record<string, FieldDefinition>;
  createdAt: Date;
}

interface FieldAnalysis {
  presentCount: number;
  types: Set<string>;
  values: any[];
  inferredType: string;
  arrayItemType?: string;
  exampleValue?: any;
}

export class SchemaDiscovery {
  static discoverSchema(data: any[], sourceName: string): AutoGeneratedSchema {
    const fields: Record<string, FieldDefinition> = {};
    const sampleSize = data.length;

    const fieldAnalysis = this.analyzeFields(data);

    for (const [fieldName, analysis] of Object.entries(fieldAnalysis)) {
      fields[fieldName] = {
        type: analysis.inferredType as 'string' | 'number' | 'boolean' | 'array' | 'object',
        required: analysis.presentCount / sampleSize >= 0.8,
        arrayItemType: analysis.arrayItemType as 'string' | 'number' | 'object' | undefined,
        defaultValue: this.getDefaultValue(analysis.inferredType),
        exampleValue: analysis.exampleValue
      };
    }

    return {
      name: `auto_${sourceName.replace(/[^a-zA-Z0-9]/g, '_')}`,
      generatedFrom: sourceName,
      sampleSize,
      fields,
      createdAt: new Date()
    };
  }

  private static analyzeFields(data: any[]): Record<string, FieldAnalysis> {
    const analysis: Record<string, FieldAnalysis> = {};

    for (const item of data) {
      for (const [key, value] of Object.entries(item)) {
        if (!analysis[key]) {
          analysis[key] = {
            presentCount: 0,
            types: new Set(),
            values: [],
            inferredType: 'string',
            arrayItemType: undefined,
            exampleValue: undefined
          };
        }

        analysis[key].presentCount++;
        analysis[key].values.push(value);

        if (value !== null && value !== undefined) {
          const type = this.inferType(value);
          analysis[key].types.add(type);

          if (!analysis[key].exampleValue) {
            analysis[key].exampleValue = value;
          }
        }
      }
    }

    for (const fieldAnalysis of Object.values(analysis)) {
      fieldAnalysis.inferredType = this.consolidateTypes(fieldAnalysis.types);
      if (fieldAnalysis.inferredType === 'array') {
        fieldAnalysis.arrayItemType = this.inferArrayItemType(fieldAnalysis.values);
      }
    }

    return analysis;
  }

  private static inferType(value: any): string {
    if (Array.isArray(value)) return 'array';
    if (typeof value === 'number') return 'number';
    if (typeof value === 'boolean') return 'boolean';
    if (typeof value === 'object') return 'object';
    return 'string';
  }

  private static consolidateTypes(types: Set<string>): string {
    if (types.size === 1) return types.values().next().value || 'string';
    if (types.has('string')) return 'string';
    if (types.has('number')) return 'number';
    return 'string';
  }

  private static inferArrayItemType(values: any[]): string {
    const itemTypes = new Set<string>();

    for (const value of values) {
      if (Array.isArray(value)) {
        for (const item of value) {
          itemTypes.add(this.inferType(item));
        }
      }
    }

    if (itemTypes.size === 1) return itemTypes.values().next().value || 'string';
    if (itemTypes.has('string')) return 'string';
    return 'string';
  }

  private static getDefaultValue(type: string): any {
    switch (type) {
      case 'string': return '';
      case 'number': return 0;
      case 'boolean': return false;
      case 'array': return [];
      case 'object': return {};
      default: return null;
    }
  }
}