import { AutoGeneratedSchema, FieldDefinition } from './auto-schema';

export interface SchemaEnforcementResult {
  success: boolean;
  data: any[];
  warnings: string[];
  errors: string[];
}

export class SchemaEnforcer {
  static enforceSchema(data: any[], schema: AutoGeneratedSchema): SchemaEnforcementResult {
    const warnings: string[] = [];
    const errors: string[] = [];
    const normalizedData: any[] = [];

    for (let i = 0; i < data.length; i++) {
      const item = data[i];
      const normalizedItem: any = {};

      for (const [fieldName, fieldDef] of Object.entries(schema.fields)) {
        if (fieldDef.required && !(fieldName in item)) {
          if (fieldDef.defaultValue !== undefined) {
            normalizedItem[fieldName] = fieldDef.defaultValue;
            warnings.push(`Item ${i}: Missing required field '${fieldName}', using default value`);
          } else {
            errors.push(`Item ${i}: Missing required field '${fieldName}' with no default value`);
            continue;
          }
        } else if (fieldName in item) {
          const value = item[fieldName];
          const coercedValue = this.coerceType(value, fieldDef.type);

          if (coercedValue !== null) {
            normalizedItem[fieldName] = coercedValue;
          } else {
            warnings.push(`Item ${i}: Field '${fieldName}' type mismatch, expected ${fieldDef.type}`);
            normalizedItem[fieldName] = fieldDef.defaultValue;
          }
        }
      }

      for (const [key, value] of Object.entries(item)) {
        if (!(key in schema.fields)) {
          normalizedItem[key] = value;
          warnings.push(`Item ${i}: Extra field '${key}' not in established schema`);
        }
      }

      normalizedData.push(normalizedItem);
    }

    return {
      success: errors.length === 0,
      data: normalizedData,
      warnings,
      errors
    };
  }

  private static coerceType(value: any, expectedType: string): any {
    if (value === null || value === undefined) return null;

    switch (expectedType) {
      case 'string':
        return String(value);
      case 'number':
        const num = Number(value);
        return isNaN(num) ? null : num;
      case 'boolean':
        if (typeof value === 'boolean') return value;
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'true' || lower === '1') return true;
          if (lower === 'false' || lower === '0') return false;
        }
        return null;
      case 'array':
        return Array.isArray(value) ? value : null;
      case 'object':
        return typeof value === 'object' && !Array.isArray(value) ? value : null;
      default:
        return value;
    }
  }
}